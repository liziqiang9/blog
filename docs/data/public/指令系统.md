
## 指令系统的概念、指令格式

概念：一台计算机能够识别的所有指令的集合称为该机的指令系统。

格式：操作码(指令码)  目标操作数   源操作数

## 对操作数的寻址方式

#### 立即寻址

只针对源操作数

此源操作数是一个立即数(8位或16位)，存放在内存的代码段中。

高位高址，低位低址。

例：MOV AX, 3102H

#### 直接寻址

参与运算的数据存放在内存中

[]内用16位常数表示存放数据的偏移地址，数据的段基地址默认为数据段，可以段重设。

例：MOV AX，[3102H]

#### 寄存器寻址

操作数为CPU的内部寄存器。可以是数据寄存器(8位或16位)，地址指针，变址寄存器或段寄存器。

指令执行时不必通过访问内存就可以取得操作数，故执行速度较快。

例：MOV SI, AX

#### 寄存器间接寻址

用寄存器的内容表示操作数的偏移地址。

只允许是 SI, DI, BX 和 BP寄存器

选择SI, DI, BX 作间址寄存器时， 操作数在数据段，段基地址由DS决定；

选择BP作间址寄存器时，操作数在堆栈段，段基地址由SS决定。

都可以段重设

例：MOV AX， ES:[SI]

#### 寄存器相对寻址

操作数在内存中的存放地址(偏移地址)由间址寄存器的内容加上指令中给出的一个8位或16位的位移量组成。

例：MOV AX DATA[BX]等价于

MOV AX, DATA + [BX]

MOV AX, [DATA + BX]

#### 基址--变址寻址

由一个基址寄存器(BX 或 BP) 的内容和一个变址寄存器(SI + DI) 的内容相加而形成操作数的偏移地址。

例：MOV AX,  \[BX][SI]

#### 基址--变址--相对寻址

由一个基址寄存器和一个变址寄存器，同时含给出一个8位或16位的位移量而形成操作数的偏移地址。

例：MOV AX, [DATA + BX + SI]

#### 隐含寻址

隐含了部分操作数的地址。

## 汇编语言程序设计

### 结构

一个完整的汇编语言源程序通常有若干个逻辑段(Segment)组成的。

每个逻辑段以SEGMENT语句开始，以ENDS语句结束，整个源程序用END语句结尾。

代码段中存放源程序的所有指令码

数据段和附加段存放数据、变量等

一个源程序模块只可以有一个代码段、一个数据段、一个附加段和一个堆栈段

例：

段名 1 SEGMENT

:

段名 1 ENDS

段名 2 SEGMENT

:

段名 2 ENDS

···

段名 n SEGMENT

:

段名 n ENDS

END

例2：

DSEG SEGMENT

DATA1 DW 0F865H

DATA2 DW 360CH

DSEG ENDS

ESEG SEGMENT

SUM DW 2 DUP (?)

ESEG ENDS

CSEG SEGMENT

 	ASSUME CS:CSEG, DS:DSEG, ES:ESEG

START: MOV AX, DSEG

​			MOV DS, AX
​			MOV AX, ESEG

​			MOV ES, AX

​			LEA SI, SUM

​			MOV AX, DATA1

​			ADD AX, DATA2

​			MOV ES:[SI], AX

​			HLT

CSEG ENDS

​			END START

### 类型及格式

1）指令性语句

由指令助记符等组成的可被CPU执行的语句

2）指示性语句

告诉汇编程序如何对程序进行汇编

### 数据项及表达式

1）常量

1. 十进制常量。以字母“D"结尾或不加结尾，如 23D, 23
2. 二进制常量。以字母”B“结尾的二进制数，如 10101001H
3. 十六进制常量。以字母”H“结尾，如 64H、0F800H。A~F开头，在前面加数字0
4. 字符串常量。用单引号括起来的一个或多个ASCLL码字符

2）标号

不能与指令助记符或伪指令重名，也不允许由数字打头，字符个数不超过31个。

指令性语句中的标号代表存放一条指令的存储单元的符号地址，其后必须加冒号。

标识符：

1. 由字母(a ~ z, A ~ Z)、数字（0 ~ 9）或某些特殊字符(@, -, ?)组成
2. 第一个字符必须是字母或特殊字符，但“？”不能单独作标识符。
3. 有效长度为31个字符。

属性：

（1）：段值属性。是标号所在段的段地址。

（2）：偏移量属性。是标号所在段的段首到定义该标号的地址之间的字节数(即偏移地址)，16位无符号数

（3）：类型

1. NEAR：近标号，只能在段内被引用，地址指针为2个字节
2. FAR：远标号，可以在其他段被引用，地址指针为4个字节

3）变量

属性：

（1）：段属性就是它所在段的段地址

（2）：偏移量属性是该变量所在段的起始地址到变量地址之间的字节数。

（3）：类型：BYTE(字节)、WORD(字)、DWORD(双字)、QWORD(四字)、TBYTE(十字节)

例：

1. NUM DB 11H, 22H, 33H

#### 表达式

本身不是指令，不能执行。（不在执行中执行，而是在汇编时计算得出一个确定的值）

**1）算术运算符**

有+、-、*、/和MOD(取余数)

例：

1. MOV AL, 8 + 5 等价于 MOV AL, 13

**2）逻辑运算符**

有AND, OR, NOT, XOR

例：

1. MOV AL, 0ADH AND 0CCH 等价于 MOV AL, 8CH

注意：

1. 不要把逻辑运算符与同名称的CPU指令相混淆。

**3）关系运算符**

有EQ(等于)、NE(不等于)、LT(小于)、GT(大于)、LE(小于等于)、GE(大于等于)

参与关系运算的必须是两个数值或同一段中的两个存储单元地址

关系不成立时，结果为0

关系成立时，结果为0FFFFH

**4）取值运算符和属性运算符**

取值运算符用来分析一个存储器操作数的属性， OFFSET、SEG.

属性运算符则可以规定存储器操作数的某个属性，PTR.

(1) OFFSET，可以得到一个标号或变量的偏移地址。

例：

1. MOV SI, OFFSET DATA1 等价于 LEA SI, DATA1

(2) SEG，可以得到一个标号或变量的段地址。

MOV AX, SEG DATA ;将变量DATA的段地址送AX

MOV DS, AX     ; DS <- AX

(3) PTR,  用来指定位于其后的存储器操作数的类型。

例：

CALL DWORD PTR[BX];

MOV AL, BYTE PTR[SI];

**5) 其他运算符**

(1) 方括号“[]”。

指令中用方括号表示存储器操作数，方括号里的内容表示操作数的偏移地址。

(2) 段重设运算符“：” 。

用来指定一个存储器操作数的段属性而不管其原来隐含的段是什么。

例：

1. MOV AX, ES:[DI]

## 伪指令

指示性语句中的伪操作命令，无论表示形式或其在语句中所处的位置都与CPU指令相似，因此也称为伪指令，但两者之间有着重要的区别。

伪操作命令在汇编过程中由汇编程序执行。

### 数据定义伪指令

用来定义变量的类型，给变量赋初值或给变量分配存储空间。

#### 格式

[变量名] 伪操作 操作数[, 操作数···]

类型：

1. DB 字节类型
2. DW 字类型
3. DD 双字类型
4. DQ 四字类型
5. DT 十字节类型

#### 操作数

可以是常数、表达式或字符串。

例：

1. DATA DB 11H, 33H

2. NUM DW 100*5 + 88

3. STB DB 'Hello!'
4. SUM DQ 0011223344556677H ;内存中存放，由低到高分别为：77H, 66H, 55H, 44H, 33H, 22H, 11H, 00H
5. ABC DT 1234567890H 内存中存放，由低到高分别为：90H, 78H, 56H, 34H, 12H, 00H, 00H, 00H，00H, 00H
6. DATA2 DW ? ;为变量DATA2分配2个字节的空间，初值为任意值

#### 重复操作数

[变量名] 数据定义伪操作 n DUP(初值[,初值···])

例：

1. DATA1 DB 20 DUP (?) ; 为变量DATA1分配20个字节的空间，初值为任意值
2. DATA3 DB 20 DUP (30H) ; 为变量DATA3分配20个字节的空间，初值均值为30H.

### 符号定义伪指令

常将该表达式赋予一个名字，以后凡是用到该表达式的地方就用这个名字来代替。

名字 EQU 表达式

表达式可以是一个常数、符号、数值表达式、地址表达式和指令助记符

例：

1. CR EQU 0DH
2. TEN EQU 0AH
3. VAR EQU TEN*2+1024
4. ADR EQU ES:[BP+DI+5] 

### 段定义伪指令

段定义伪指令用来定义汇编语言源程序中的逻辑段。

段名 SEGMENT [定位类型] [组合类型] ['类别']

···

段名 ENDS

1) 定位类型

告诉汇编程序如何确定逻辑段的地址边界。

(1) PARA

说明逻辑段从一个节的边界开始， 16个字节称为一个节。 

(2) BYTE

说明逻辑段从字节边界开始，即可以从任何地址开始。

(3) WORD

说明逻辑段从字边界开始，即本段的起始地址必须是偶数。

(4) PAGE

说明逻辑段从页边界开始，256字节称为一页。

2）组合类型

主要用在具有多个模块的程序中

(1) NONE

表示本段与其他逻辑段不组合

(2) PUBLIC

表示对于不同程序模块中用PUBLIC说明的具有相同段名的逻辑段，汇编是将它们组合在一起，构成一个大的逻辑段。

(3) STACK

含义与PUBLIC基本一样，但仅限于作为堆栈的逻辑段使用。

(4) COMMON

表示对于不同程序模块中用COMMON说明的同名逻辑段，连接时从同一地址开始装入，即各个逻辑段重叠在一起

(5) MEMORY 

表示当几个逻辑段连接时，本逻辑段定位在地址最高的地方。

(6) AT表达式

表示本逻辑段根据表达式求值的结果定位段地址。

3）类别

是单引号括起来的字符串

作用：当几个程序模块进行连接时，将具有相同类别名的逻辑段装入连续的内存区中。

### 设定段寄存器伪指令

ASSUME 段寄存器名：段名[,段寄存器：段名[,···]]

用于向汇编程序说明所定义的逻辑段属于何种类型的逻辑段。

例：

```ASM
CODE SEGMENT PARA PUBLIC 'CODE'
	ASSUME CS:CODE, DS:DATA, ES:EDATA, SS:STACk
	MOV AX, DATA
	MOV DS, AX
	MOV AX, EDATA
	MOV ES, AX
	MOV AX, STACK
	MOV SS, AX
	···
CODE ENDS 
```



### 过程定义伪指令

通常将具有某种功能的程序段看作一个过程(即子程序)，它可以被别的程序调用(CALL).

过程名 PROC [NEAR/FAR]

​	···

​	RET

过程名 ENDP

过程名实际是过程入口的符号地址

例：

```ASM
DELAY PROC
	POSH BX
	POSH CX
	MOV BL, 2
NEXT: MOV CX, 4167
W10MS: LOOP W10MS
	DEC BL
	JNZ NEXT
	POP CX
	POP BX
	RET
DELAY ENDP
```

### 宏命令伪指令

需要多次使用同一个程序段，可以将这个程序段定义为一个宏指令，然后每次需要时即可简单地用宏指令名来代替(称为宏调用)

宏命令名 MACRO [形式参数，···]

​	[宏定义体]

​	ENDM

例：

```ASM
DADD MACRO X, Y, Z
	MOV AX, X
	ADD AX, Y
```

宏调用与过程调用区别：

1. 宏命令伪指令由宏汇编程序MASM在汇编过程中进行宏定义体替换，
2. 宏命令简化了源程序，不能简化目标程序。

### 模块定义与连接伪指令

1）NAME 伪指令

用于给汇编后得到的目标程序一个名字

NAME 模块名

2）TITLE 伪指令

为程序清单的每一页指定打印的标题

TITLE 标题名

要求：

1. 标题名最多允许60个字符

3）END伪指令

表示源程序到此结束，指示汇编程序停止汇编。

END [标号]

## DOS功能调用

所有的DOS系统功能调用都是利用软中断指令INT 21H来实现的。

使用方法：

① AH <-- 功能号

② 在指定寄存器中放入该功能所要求的入口参数

③ 执行INT 21H指令

④ 分析出口参数

### 1. 键盘输入

1）单符号输入

功能号1、7和8都可以接收键盘输入的单字符，输入的字符以ASCLL码形式存放在AL中

7、8号功能无回显，1号功能有回显(回显是指键盘输入的内容同时也显示在显示器上)

例：

```ASM
KEY:MOV AH, 1
	INT 21H
	CMP AL, 'Y'
	JE YES
	CMP AL, 'N'
	JE NOT
	JMP KEY
YES:
	···
NOT:
	···
```

2）字符串输入

输入字符串可通过调用DOS功能的0AH号功能来实现。

该功能要求用户指定一个输入缓冲区来存放输入的字符串

 |-------------------------n+2个字节的输入缓冲区---------------------------------|

-|--缓冲区长度n--|--实际读入的字符个数-- |--n个字节的预留内存区--|-

-1----------------------2--------------------------------3-(DOS从键盘读入的字符放在此处)-n+2-

1. 第一个字节为用户定义的缓冲区长度(包括回车符)
2. 第二个字节为实际输入的字符数(不包括回车符)
3. 第三个字节开始存放输入的字符

例：

从键盘上输入字符串"HELLO",并在串尾加结束标志"$".

```ASM
DATA SEGMENT
	STRING DB 10, 0, 10 DUP (?)
DATA ENDS
CODE SEGMENT
	ASSUME CS:CODE,DS:DATA
START: MOV AX, DATA
		MOV DS, AX
		LEA DX, STRING
		MOV AH, 0AH
		INT 21H
		MOV CL, STRING + 1
		XOR CH, CH
		ADD DX, CX
		MOV BX, DX
		MOV BYTE PTR[BX + 2], '$'
		MOV AH, 4CH
		INT 21H
		CODE ENDS
			END START
```

### 2. 显示器输出

1）单字符显示

用功能2显示一个字符的程序如下：

```ASM
···
MOV DL, <要显示的字符>
MOV AH, 2
INT 21H
···
```

用功能6显示一个字符的程序如下：

```ASM
···
MOV DL, <要显示的字符>
MOV AH, 6
INT 21H
···
```

2）字符串显示

9号功能是DOS调用独有的，要求被显示的字符串必须以"$"字符作为结束符

应在字符串结束前加上回车及换行的ASCII码0DH和0AH

例：

在屏幕上显示欢迎字符串"Hello,World!"

```ASM
DSEG SEGMENT
	STRING DB 'Hello,World!', 0DH, 0AH, '$'
DSEG ENDS
CSEG SEGMENT
	ASSUME CS:CSEG, DS:DSEG
START: MOV AX, DSEG
		MOV DS, AX
		LEA DX, STRING
		MOV AH, 09H
		INT 21H
		MOV AH, 4CH
		INT 21H
	CSEG ENDS
	END START
```

### 3. 返回到DOS

一个实际可执行完成后，应该返回到DOS提示符状态。

HLT指令只能使CPU停止运行，无法把控制权交还给DOS操作系统。

DOS系统功能调用4CH号功能，正常退出并返回DOS。

例：

```ASM
MOV AH, 4CH
INT 21H
```
