## 类库

`java.lang` 这个包是默认导入的

### import关键字导入包

1. `import java.util.Scanner;` 导入包名加类名
2. `import java.util.*;` 导入包名加星号， 星号代表包中所有类。

### java.util.Scanner 处理键盘输入

Scanner 的常用方法有以下两大类。

**接受键盘输入**：

名称形式是 nextXXX() 其中 XXX 表示具体的数据类型

例:

1. `byte nextByte()`

**判断是否有相应数据类型的输入**：

名称形式是 hasNextXXX() 其中 XXX 表示具体的数据类型

例:

1. `boolean hasNextInt()` 、`boolean hasNextInt(int radix)` radix为指定基数

### String 类

只读字符串

**方法**：

`public int length()`: 返回字符串的长度。

`public boolean equals(Object anObject)`: 将字符串与参数 anObject 指定的字符串进行内容比较。

### StringBuffer 类

内容可修改的字符串

## 变量

### final 变量

只能初始化一次，可声明时赋值或后续代码赋值。

### 基本类型

八种基本类型不是类和对象模式，然后提供了对应的 [包装类](#基本数据类型的包装类)。

1. 整数类型: byte 、short 、int 、long （后加L) 。
2. 浮点类型: float （小数后加F） 、double 。
3. 字符类型: char (2B)。
4. 逻辑类型: boolean (取值： true 或 false)。

#### 包装类

由于基本类型都不是表示对象的引用类型，造成了很多不变，因此为这8种基本类型提供了8个对应的包装类

| 包装类    | 对应基本类型 |
| --------- | ------------ |
| Byte      | byte         |
| Short     | short        |
| Integer   | int          |
| Long      | long         |
| Float     | float        |
| Double    | double       |
| Character | char         |
| Boolean   | boolean      |

### 引用类型

1. 数组
2. 类 
   1. 系统类
   2. 自己的类

## 访问控制修饰符

1. *public*： 访问范围是所有类。
2. *private*： 访问范围是只能自己所在的类。
3. *protected*： 访问范围是同一个包的类，以及其他包的子类。
4. *default(默认访问权限)*: 访问范围是同一个包的类。


## 类（class）

### 结构

**成员变量**：

* 实例变量
* 类变量 (static 修饰)

**成员方法**：

* *实例方法* ：对象调用时才运行
* *类方法* ：随着类加载进入内存，但是并没有执行，当类名调用他时才会执行

**构造方法**：

**静态初始器**: 静态代码块，第一个运行的代码，类加载他就运行，自动运行的，而且只运行一次，一般作为初始化工作。

``` java
class My{
    static {
        // 静态初始器
    }
}
```

**实例初始器**: 普通代码块, 每次生成对象，都会执行，自动的，比构造方法执行要早

``` java
class My{
    {
        // 实例初始器
    }
}
```

### 继承 （extends）

java是单根继承的，即每个类只能有一个父类，如果没写父类是谁，那就是 Object 类

### 重写

子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。

1. 同名同参
2. 子类覆盖父类方法，方法修饰权限只能扩大，不可缩小
3. 子类覆盖父类方法，返回值必须保持一致

### 重载

同名不同参 —— 参数个数、类型、顺序有一个不同即为不同

### this

this(xxx) 或 this() ，放在构造方法第一句话，表示调用本类其他构造方法

### super

super(xxx) 或 super() ，放在构造方法第一句, 表示调用父类的构造方法, 构造方法不写时默认调用super() 

## 抽象 (abstract)

### 抽象类

抽象类不能生成对象， 抽象类的作用是让其他类继承

抽象类不能声明为 final 类

1. 一个类，只要包括一个抽象方法，那么，这个类必须定义成抽象类
2. 一个类，如果没有抽象方法，也可以定义成抽象类

### 抽象方法

当一个方法没有办法具体实现，可以修饰为abstract，表示这是一个抽象方法

1. 必须用 abstract 修饰，不能有实现代码。
2. 不能声明为 final 方法，访问权限不能为 private。
3. 不能声明为静态 (static) 方法。

## 接口 (interface) 

**特点**：

* 接口成员的访问权限都隐含默认为 public。
* 接口方法都隐含默认为抽象方法， 即默认被 abstract 所修饰。
* 所有字段都隐含默认为静态常量，即被 `static final` 所修饰。

实现 (implements) 是多重继承的一个替代方案

1. 接口和接口之间继承关系，接口A可以继承（extends）接口B，接口C
2. 类和类之间继承关系，类A继承类B，单根继承
3. 类和接口之间实现关系，类A可以实现（implements）接口B，接口C
4. 类也可以继承类A，同时实现接口B，接口C
5. 类B继承类A，A是父类，B是子类，可以用多态，A类定义引用指向B类对象
6. 类B实现接口A，也可以用多态，A接口定义引用指向B类对象
7. 接口和类是平级的
8. 一个类实现了接口，就必须实现接口的方法，否则定义为抽象类，供子类实现

### 设计和实现分离

接口啥都没干 —— 他是一种设计
实现接口的类 —— 是具体实现

